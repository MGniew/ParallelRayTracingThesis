\section{Szczegółowy opis klas}
	\subsection{RayTracer}
	
\begin{lstlisting}

void RayTracer::recursiveRayTracer(int depth) {

Vector3<float> worldPosOfPixel;
Vector3<float> directionVector;

for(int i = 0; i < scene->getWidth(); i++) {
    for(int j = 0; j < scene->getHeight(); j++) {
        worldPosOfPixel = camera->getWorldPosOfPixel(i + scene->getStartX(),j + scene->getStartY());
        directionVector = worldPosOfPixel - *camera->getEye();
        directionVector.normalize();
        scene->setPixelColor(i, j, getColorRecursive(worldPosOfPixel, directionVector, depth));
    }
}
}
\end{lstlisting}	

\begin{lstlisting}

Vector3<float> RayTracer::getColorRecursive(Vector3<float> startPoint, Vector3<float> directionVector, int depth)
{

SceneObject* sceneObject;
Vector3<float> crossPoint;
Vector3<float> reflectedRay;
Vector3<float> localColor;
Vector3<float> reflectedColor;

//refraction
Vector3<float> transparencyColor;
Vector3<float> transparencyRay;

if (depth == 0)
    return Vector3<float>();

depth--;

sceneObject = scene->getClosest(crossPoint, startPoint, directionVector);

if (sceneObject == nullptr)
    return Vector3<float>(*scene->backgroundColor);

Vector3<float> normalVector = sceneObject->getNormalVector(crossPoint);
Vector3<float> observationVector = directionVector*-1;


if (observationVector.scalarProduct(normalVector) < 0) {
    normalVector = normalVector*-1;
}

crossPoint = crossPoint + normalVector*EPSILON;
if(sceneObject->getTransparency()>0) {
    transparencyRay = directionVector.refract(normalVector, sceneObject->getDensity(), 1);
    transparencyColor = getColorRecursive(crossPoint, transparencyRay, depth);
}

if (sceneObject->getLocal()>0) {
    localColor.setValues(sceneObject->getLocalColor(normalVector, crossPoint, observationVector));
}

if (sceneObject->getMirror()>0) {
    reflectedRay = directionVector.reflect(normalVector);
    reflectedColor = getColorRecursive(crossPoint, reflectedRay, depth);
}

return localColor*sceneObject->getLocal() + reflectedColor*sceneObject->getMirror() + transparencyColor*sceneObject->getTransparency();

}

\end{lstlisting}
	
	\subsection{BSP}
	
\begin{lstlisting}

SceneObject *BSP::intersect(BSP::node *root, Vector3<float> &crossPoint, Vector3<float> &startingPoint, Vector3<float> &directionVector) {

if (root->back == nullptr && root->front == nullptr) {
    return getClosestInNode(root->polygons, crossPoint, startingPoint, directionVector);
}

SceneObject *thisNodeHit = nullptr;
Vector3<float> tempCross;

if(!root->polygons.empty()) {
    thisNodeHit = getClosestInNode(root->polygons, tempCross, startingPoint, directionVector);
}

node *near;
node *far;
SceneObject *hit = nullptr;;


switch (root->partitionPlane.classifyPoint(&startingPoint)) {
    case FRONT:
        near = root->front;
        far = root->back;
    break;

    case BACK:
        near = root->back;
        far = root->front;
    break;

    case COINCIDENT: {

        Vector3<float> point = startingPoint + directionVector;
        if (root->partitionPlane.classifyPoint(&point) == FRONT) {
            near = root->front;
            far = root->back;
        }
        else {
            near = root->back;
            far = root->front;
        }
    }
    break;

    default:
        return nullptr;
        break;
}

hit = intersect(near, crossPoint, startingPoint, directionVector);

if (hit == nullptr && root->partitionPlane.rayIntersectPlane(startingPoint,directionVector)) {
    hit = intersect(far, crossPoint, startingPoint, directionVector);
}

if (thisNodeHit != nullptr) {
    if (hit != nullptr) {
        if (tempCross.distanceFrom(startingPoint) < crossPoint.distanceFrom(startingPoint)) {
            hit = thisNodeHit;
            crossPoint = tempCross;
        }
    }
    else {
        hit = thisNodeHit;
        crossPoint = tempCross;
    }
}
return hit;
}

\end{lstlisting}

\subsection{MasterThread}
	
	
\begin{lstlisting}

void MasterThread::run() {

double time = 0; double bsp = 0;
int n = test;
double t1, t2;
emitNames();

t1 = MPI_Wtime();
waitUntillRdy();
t2 = MPI_Wtime();
bsp = t2 - t1;

while (true) {

    splitToChunks(numChunks);

    t1 = MPI_Wtime();
    pending = 0;
    for (int i=1; i<worldSize; i++) {
        if (!sendNextChunk(i)) break;
        processSpeed[i][2] = MPI_Wtime();
        pending++;
        }

    int dest;
    while(pending>0) {
        switch(recvMessage()) {
            case EXIT: return; break;
            case PIXELS:
                dest = recvPixels(status);
                updateProcessSpeed();
                if (!sendNextChunk(dest))
                    pending--;
                break;
            default: break;
        }
        // emit workIsReady();
        emit processInfo(processSpeed);
    }
    t2 = MPI_Wtime();

    emit setTime(t2-t1);
    time += t2 - t1;

    //update camera pos
    camera->rotate();
    //broadcast camera
    sendCameraPointToPoint();

    emit workIsReady();

    if (n > 0) {
        n --;
        if (n == 0) break;
    }

}

printResult(time/test, bsp);
emit close();
}

\end{lstlisting}


\subsection{SlaveMPI}

\begin{lstlisting}

int SlaveMPI::exec() {

RayTracer rayTracer;
while(true) {

    switch(recvMessage()) {
        case EXIT:
            return EXIT; break;
        case CHUNK:
            recvChunk();
            rayTracer.recursiveRayTracer(depth);
            sendPixels(); break;
        case DEPTH:
            recvDepth(); break;
        case CAMERA:
            recvCameraPointToPoint(); break;
        default: break;
    }
}
return 0;
}

\end{lstlisting}

\section{Serializacja}


\begin{lstlisting}

#ifndef SERIALIZABLE_H
#define SERIALIZABLE_H

#include "vector"

class Serializable
{
public:

    virtual void serialize(std::vector<char> *bytes) = 0;
    virtual void deserialize(const std::vector<char>& bytes) = 0;
    virtual char getType() = 0;
    virtual ~Serializable();
    int serializedSize;

};

#endif // SERIALIZABLE_H

\end{lstlisting}



\begin{lstlisting}
void Sphere::serialize(std::vector<char> *bytes)
{
    bytes->resize(serializedSize);
    char *ptr = bytes->data();
    std::vector<char> vec;

    amb->serialize(&vec);
    memcpy(ptr, vec.data(), vec.size()); ptr += vec.size();
    dif->serialize(&vec);
    memcpy(ptr, vec.data(), vec.size()); ptr += vec.size();
    spec->serialize(&vec);
    memcpy(ptr, vec.data(), vec.size()); ptr += vec.size();

    memcpy(ptr, &specShin, sizeof(specShin)); ptr += sizeof(specShin);

    pos->serialize(&vec);
    memcpy(ptr, vec.data(), vec.size()); ptr += vec.size();

    memcpy(ptr, &radius, sizeof(radius)); ptr += sizeof(radius);
    memcpy(ptr, &transparency, sizeof(transparency)); ptr += sizeof(transparency);
    memcpy(ptr, &mirror, sizeof(mirror)); ptr += sizeof(mirror);
    memcpy(ptr, &local, sizeof(local)); ptr += sizeof(local);
    memcpy(ptr, &density, sizeof(density));
}
\end{lstlisting}


\begin{lstlisting}
void Sphere::deserialize(const std::vector<char> &bytes)
{
    const char* ptr = bytes.data();
    std::vector<char> vec;
    vec.resize(Vector3<float>::serializedSize);
    memcpy(vec.data(), ptr, vec.size()); ptr += vec.size();
    amb->deserialize(vec);
    memcpy(vec.data(), ptr, vec.size()); ptr += vec.size();
    dif->deserialize(vec);
    memcpy(vec.data(), ptr, vec.size()); ptr += vec.size();
    spec->deserialize(vec);

    memcpy(&specShin, ptr, sizeof(specShin)); ptr += sizeof(specShin);

    memcpy(vec.data(), ptr, vec.size()); ptr += vec.size();
    pos->deserialize(vec);

    memcpy(&radius, ptr, sizeof(radius)); ptr += sizeof(radius);
    memcpy(&transparency, ptr, sizeof(transparency)); ptr += sizeof(transparency);
    memcpy(&mirror, ptr, sizeof(mirror)); ptr += sizeof(mirror);
    memcpy(&local, ptr, sizeof(local)); ptr += sizeof(local);
    memcpy(&density, ptr, sizeof(density));
}
\end{lstlisting}