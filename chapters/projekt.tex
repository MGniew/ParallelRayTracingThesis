\section{Projekt klastra}

	Napisz coś mądrego + schemat
	
	\subsection{Master} Opisz co ma robić master
	\subsection{Slave} Opisz co ma robić slave
\section{Projekt programu}

	Tu napisz co to ma robić
	
	\subsection{Diagram klas}
	
	Poniżej przedstawiono uproszczony diagram klas. Ze względu estetycznych, opis poszczególnych z nich znajduje się w kolejnym podrozdziale. wstaw grafikę
	
	
	\subsection{Opis klas}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    BoundingBox \\ \hline
    +minX : float \\
    +maxX : float \\
    +minY : float \\
    +maxY : float \\
    +minZ : float \\
    +maxZ : float \\ 
    \hline
	+intersect(start: Vector3$<$float$>$, dir: Vector3$<$float$>$ \\ 
	\hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    BSP \\ \hline
    +tree : node* \\
    -polygons : SceneObject* \\
    -box : BoundingBox \\ 
	\hline
	+build(root : node*, polygons : SceneObject*, depth : int) \\ 
	-getBestPlane(polygons : list$<$SceneObject*$>$) : Plane \\
	+getClosest(crossPoint : Vector3$<$float$>$\&, startingPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&) : SceneObject* \\
	+isInShadow(crossPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&, lightPos : Vector3$<$float$>$\&) : bool \\
	-getBoundingBox(polygons : std.list$<$SceneObject*$>$) : BoundingBox \\
	-intersect(root : node*, crossPoint : Vector3$<$float$>$\&, startingPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&) : SceneObject * \\
	-getClosestInNode(polygons : std.list$<$SceneObject*$>$, crossPoint : Vector3$<$float$>$\&, startingPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&) : SceneObject * \\
	-isInShadow\_tree(root : node*, crossPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&, LightDistance : float) : bool \\
	-deleteTree(root : node*) : void \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    Node \\ \hline
    Plane partitionPlane \\
    std::list$<$SceneObject*$>$ polygons \\
    node* front \\
    node* back \\ \hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    GLwidget \\ \hline
    Scene* scene; \\ \hline
    void initializeGL(); \\ 
    void resizeGL(int w, int h); \\
    void paintGL(); \\ \hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    FileLoader \\ \hline
    -readCameraSettings(line : char const*) : bool \\
    -readSceneSettings(line : char const*) : bool \\
    -readSphere(line : char const*) : bool \\
    -readLight(line : char const*) : bool \\
    -readTriangle(line : char const*) : bool \\
    -readObj(line : char const*) : bool \\
	+ReadFile(fname : char const*) : bool \\ \hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    InputParser \\ \hline
    std::vector$<$std::string$>$ tokens; \\ \hline
    +getCmdOption(option : std.string const\&) : std.string const\&) \\
    +cmdOptionExists(option : std.string const\&) : bool \\ \hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    Light \\ \hline
    +pos : Vector3$<$float$>$* \\ 
    +amb : Vector3$<$float$>$* \\
    +dif : Vector3$<$float$>$* \\
    +spec : Vector3$<$float$>$* \\
    \hline
	+serialize(bytes : std.vector$<$char$>$*) : void \\ 
	+deserialize(bytes : std.vector$<$char$>$ const\&) : void \\
	+getType() : char \\
	\hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    Nazwa klasy \\ \hline
    Spis atrybutów \\ \hline
	Spis metod \\ \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    MainWindow  \\ \hline
    Ui::MainWindow *ui; \\
    StatisticsWindow *statisticWindow; \\
    MasterThread *masterThread; \ \
    QLabel* statusLabel; \\ \hline
    void createMaster() \\
    void ShowStats(); \\
    void setSpeed(double time); \\
    void on\_actionStatistics\_triggered(); \\
    void onQuit(); \\ \hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    MasterThread  \\ \hline
    bool isAlive; \\
    Camera* camera; \\
    Scene* scene; \\
     double** processSpeed; \\
         int worldSize; \\
    MPI\_Status status; \\
        std::vector$<$std::string$>$ names; \\
    int pending; \\
    int numChunks; \\
    std::queue$<$Chunk$>$ queue; \\
    int test; \\
    \hline
	void run() \\
	void splitToChunks(int num); \\
	 void clearQueue(std::queue$<$Chunk$>$ \&q); \\
    void sendCameraBcast(); \\
    void sendCameraPointToPoint(); \\
    void sendScene(); \\
    void sendDepth(int depth); \\
    bool sendNextChunk(int dest); \\
    void sendExitSignal(); \\
    int recvPixels(MPI\_Status \&stat); \\
    int recvMessage(); \\
    void finishPending(); \\
    void updateProcessSpeed(); \\
    void waitUntillRdy(); \\
    void printResult(double spf, double bsp); \\
    void getNames(); \\
    void emitNames(); \\
	\hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    Chunk \\ \hline
    int startx, stopx; \\
    int starty, stopy;  \\
    \hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    Pixels \\ \hline
    +data : unsigned char* \\
    +x : int \\
    +y : int \\ 
    +startx : int \\
    +starty : int \\
    \hline
	+serialize(bytes : std.vector$<$char$>$*) : void \\
	+deserialize(bytes : std.vector$<$char$>$ const\&) : void \\
	+getType() : char \\
	+setStartXY(x : int, y : int) : void \\
	+setPixel(posX : int, posY : int, vec : Vector3$<$float$>$\&) : void \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    Plane \\ \hline
    +a : float \\ 
    +b : float \\
    +c : float \\
    +d : float \\
    \hline
	Spis metod \\ 
	+classifyObject(obj : SceneObject*) : int \\
	+classifyPoint(point : Vector3$<$float$>$*) : int \\
	+getDistToPoint(point : Vector3$<$float$>$*) : float \\
	+rayIntersectPlane(startingPoint : Vector3$<$float$>$, directionVector : Vector3$<$float$>$) : bool \\
	+getNormal() : Vector3$<$float$>$ \\
	+isValid() : bool \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    RayTracer \\ \hline
    +camera : Camera* \\
    +scene : Scene* \\
    +buffer : Vector3$<$float$>$*** \\ \hline
	+basicRayTracer() : void \\
	+recursiveRayTracer(depth : int) : void \\
	+getColorRecursive(startPoint : Vector3$<$float$>$, directionVector : Vector3$<$float$>$, depth : int) : Vector3$<$float$>$ \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    Scene \\ \hline
    +numOfLights : int \\
    +numOfObjects : int \\
    +useShadows : bool \\
    +useBSP : bool \\
    +instance : Scene* \\
    +lights : Light** \\
    +sceneObjects : SceneObject** \\
    +pixels : Pixels* \\
    +backgroundColor : Vector3$<$float$>$* \\
    +globalAmbient : Vector3$<$float$>$* \\
    +bsp : BSP* \\
    \hline
	+getInstance() : Scene * \\
	+buildBSP(depth : int) : void \\
	+addObject(sceneObject : SceneObject*) : void \\
	+addLight(light : Light*) : void \\
	+setUpPixels(x : int, y : int) : void \\
	+getClosest(crossPoint : Vector3$<$float$>$\&, startPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&) : SceneObject * \\
	+isInShadow(crossPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&, lightPos : Vector3$<$float$>$\&) : bool \\
	+setPixelColor(x : int, y : int, color : Vector3$<$float$>$) : void \\
	+serialize(bytes : std.vector$<$char$>$*) : void \\
	+deserialize(bytes : std.vector$<$char$>$ const\&) : void \\
	+getType() : char \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    SceneObject \\ \hline
    \#specShin : float \\
    \#transparency : float \\
    \#mirror : float \\
    \#local : float \\
    \#density : float \\
    \#amb : Vector3$<$float$>$* \\
    \#dif : Vector3$<$float$>$* \\
    \#spec : Vector3$<$float$>$* \\
    \hline
	+getLocalColor(normalVector : Vector3$<$float$>$\&, crossPoint : Vector3$<$float$>$\&, observationVector : Vector3$<$float$>$\&) : Vector3$<$float$>$ \\
	+trace(crossPoint : Vector3$<$float$>$\&, startPoint : Vector3$<$float$>$\&, directionVector : Vector3$<$float$>$\&, dist : float\&) : bool \\
	+getNormalVector(crossPoint : Vector3$<$float$>$\&) : Vector3$<$float$>$ \\
	+getBoundingBox() : BoundingBox \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    Serializable \\ \hline
    +serializedSize : int \\ \hline
	+serialize(bytes : std.vector$<$char$>$*) : void \\ 
	+deserialize(bytes : std.vector$<$char$>$ const\&) : void \\
	+getType() : char \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    SlaveMPI \\ \hline
    +x : int \\ 
	+y : int \\
	+depth : int \\
	+status : MPI\_Status \\
	+pixels : Vector3$<$float$>$*** \\
	+camera : Camera* \\
	+scene : Scene* \\ \hline
	+exec() : int \\
	+recvCameraBcast() : void \\
	+recvCameraPointToPoint() : void \\
	+recvScene() : void \\
	+recvDepth() : void \\
	+recvChunk() : void \\
	+recvMessage() : int \\
	+sendPixels() : void \\
	+sendName() : void \\
	+sendRdy() : void \\
	\hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    StatisticsWindow \\ \hline
    Ui::StatisticsWindow *ui; \\
    int worldSize; \\
    \hline
	void resizeEvent(QResizeEvent *event); \\
    void setTime(double time); \\
    void setChunks(int i); \\
    void setXY(int x, int y); \\
    void setObj(int i); \\
    void setLights(int i); \\
    void setProccessName(int num, QString str); \\
    void setProccessSpeed(double **speed); \\
    void setUpList(); \\
    \hline
    \end{tabular}
\end{center}


TINY OBJECTY LOADER!!!!!!!!!

\begin{center}
    \begin{tabular}{|l|}
    \hline
    Sphere \\ \hline
    +radius : float \\
    +pos : Vector3$<$float$>$* \\
    \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{|l|}
    \hline
    Triangle \\ \hline
    +pointA : Vector3$<$float$>$* \\
    +pointB : Vector3$<$float$>$* \\
    +pointC : Vector3$<$float$>$* \\
    +normalA : Vector3$<$float$>$* \\
    +normalB : Vector3$<$float$>$* \\
    +normalC : Vector3$<$float$>$* \\
    \hline
	+split(plane : Plane, front : std.list$<$Triangle*$>$\&, back : std.list$<$Triangle*$>$\&) : void \\ 
	+getPointbyNum(a : int) : Vector3$<$float$>$ * \\
	+getPlanes() : std.list$<$Plane$>$ \\
	+getPerpendicularPlane(i : int) : Plane \\
	+getPlane() : Plane \\
	+Area(a : Vector3$<$float$>$, b : Vector3$<$float$>$) : float \\
	+getBoundingBox() : BoundingBox \\
	\hline
    \end{tabular}
\end{center}


\begin{center}
    \begin{tabular}{|l|}
    \hline
    Vector3 \\ \hline
    +x : type \\
    +y : type \\
    +z : type \\
     \hline
	+normalize() : Vector3 \\ 
	+scalarProduct(v : Vector3\&) : float \\
	+vectorProduct(v : Vector3\&) : Vector3 \\
	+rotateX(alpha : float) : void \\
	+rotateY(alpha : float) : void \\
	+rotateZ(alpha : float) : void \\
	+distanceFrom(v : Vector3\&) : float \\
	+powDistanceFrom(v : Vector3\&) : float \\
	+reflect(n : Vector3\&) : Vector3$<$float$>$ \\
	+refract(normalVector : Vector3\&, a : float, b : float) : Vector3$<$float$>$ \\
	+isZeroVector() : bool \\
	+length() : float \\
	\hline
    \end{tabular}
\end{center}


